
import { createClient } from 'npm:@supabase/supabase-js@2';
Deno.serve(async (req)=>{
  if (req.method === 'OPTIONS') return new Response(null, {
    status: 204
  });
  // Read env with sensible fallbacks (use the actual names you configured)
  const SUPABASE_URL = Deno.env.get('URL') ?? Deno.env.get('SUPABASE_URL') ?? '';
  const ANON_KEY = Deno.env.get('ANON_KEY') ?? Deno.env.get('SUPABASE_ANON_KEY') ?? '';
  if (!SUPABASE_URL || !ANON_KEY) {
    return new Response(JSON.stringify({
      error: 'Missing env keys'
    }), {
      status: 500
    });
  }
  // Try to get userId from body (preferred) or querystring as fallback
  let userId = null;
  try {
    if (req.headers.get('content-type')?.includes('application/json')) {
      const body = await req.json().catch(()=>null);
      if (body && typeof body.userId === 'string') userId = body.userId;
    }
  } catch (e) {
  // ignore
  }
  // fallback: parse from URL query
  if (!userId) {
    try {
      const reqUrl = typeof req.url === 'string' ? req.url : '';
      const parsed = new URL(reqUrl, SUPABASE_URL) // base ensures relative URLs parse
      ;
      userId = parsed.searchParams.get('userId');
    } catch (e) {
    // ignore parsing error
    }
  }
  if (!userId) return new Response(JSON.stringify({
    error: 'userId required'
  }), {
    status: 400
  });
  // Auth header and token
  const authHeader = req.headers.get('Authorization') ?? '';
  const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;
  if (!token) return new Response(JSON.stringify({
    error: 'Authorization token required'
  }), {
    status: 401
  });
  // Create anon client with Authorization header to act as the user
  const anonClient = createClient(SUPABASE_URL, ANON_KEY, {
    auth: {
      persistSession: false,
      autoRefreshToken: false,
      detectSessionInUrl: false
    },
    global: {
      headers: {
        Authorization: `Bearer ${token}`
      }
    }
  });
  // Validate token and get user
  const { data: userData, error: userError } = await anonClient.auth.getUser();
  if (userError || !userData?.user) return new Response(JSON.stringify({
    error: 'Invalid token'
  }), {
    status: 401
  });
  const requesterUid = userData.user.id;
  if (requesterUid !== userId) return new Response(JSON.stringify({
    error: 'Forbidden'
  }), {
    status: 403
  });
  const confirmed = !!userData.user.email_confirmed_at;
  if (!confirmed) {
    return new Response(JSON.stringify({
      confirmed: false
    }), {
      headers: {
        'Content-Type': 'application/json'
      },
      status: 200
    });
  }
  // Try to create profile (RLS must allow authenticated insert where user_id = auth.uid())
  let profileCreated = false;
  try {
    const insertResp = await anonClient.from('profiles').insert([
      {
        user_id: requesterUid
      }
    ]).select();
    if (insertResp.error) {
      // ignore unique_violation (23505) â€” profile exists
      if (insertResp.error.code === '23505') {
        profileCreated = false;
      } else {
        // other errors: return 500
        return new Response(JSON.stringify({
          error: insertResp.error.message
        }), {
          status: 500
        });
      }
    } else {
      profileCreated = true;
    }
  } catch (e) {
  // ignore unexpected
  }
  return new Response(JSON.stringify({
    confirmed: true,
    profileCreated
  }), {
    headers: {
      'Content-Type': 'application/json'
    },
    status: 200
  });
});
